---
title: "Hintzman 1986"
author: "Matt Crump"
date: "August 30, 2016"
output:
  html_document:
    toc: yes
    keep_md: TRUE
---

# 1986 Simulation 1: Abstraction

Load libraries

```{r,echo=FALSE}
library(lsa) #has cosine function
library(ggplot2) # for plotting
library(Crump)
library(plyr)
library(xtable)
library(knitr)
```

Each memory trace and each probe was a 23 unit vector. 

Units 1-10 represented the category name, and 11-23 represented the stimulus pattern. Each unit had a .5 probability of being assigned a +1 (activated unit) or a -1 (inhibited unit).

Three category names and prototypes were used in the simulations.

## Construct three category names and prototype patterns

Create a 3 (rows) x 23 (columns) matrix, with each unit assigned 1 or -1 with p=.5

Use the following functions

- runif(n,min,max) - samples n times from a uniform distribution between min and max
- sign() - converts digits to 1 or -1
- matrix(vector,nrow,ncol) converts vector to a matrix

```{r}
CategoriesPrototypes <- matrix(sign(runif(3*23,-1,1)),nrow=3,ncol=23)
```

## Create Distortions of the prototype pattern

Distortions of each prototype pattern (exemplars of a category) were generated by randomly selecting two (low distortion) or four (high distortion) units from each prototype and flipping their sign (multiply by -1).

```{r}
DistortedExemplars <- matrix(nrow = 18, ncol = 23)  # Create empty matrix with room for 3, 6, and 9 exemplars from each category
rowCounter <- 0  # initialize row counter to insert distortions into matrix

# repeat for each category (rows)
for (m in 1:3) {
    # create x number of distortions per category
    for (numberOfDistortions in 1:3) {
        rowCounter <- rowCounter + 1  # increment on each loop, simple index
        ones <- rep(1, 23)  # creates a vector of 23 ones
        ones[sample(seq(11, 23), 2)] <- c(-1)  # randomly sample two units from the prototype pattern and change value to -1
        DistortedExemplars[rowCounter, ] <- ones * CategoriesPrototypes[m, ]  # multiply prototype by distortion pattern and save in matrix
    }
}
```

## Function to get an echo from a memory

MINERVA compares a probe pattern to all stored exemplars in memory. Each exemplar is weighted by it's similarity to the probe. The weighted vectors are summed into the echo.

```{r}
# probe is the input vector, mem is the matrix of exemplars
# requires LSA package for cosine

getEcho <- function(probe, mem) {
    simvals <- c()  # empty vector for similarities between probe and memory traces
    for (m in 1:dim(mem)[1]) {
        simvals[m] <- cosine(probe, mem[m, ])  # Compute Similarities
    }
    echomat <- mem * (simvals^3)  # Multiply memory traces by similarity^3
    echo <- colSums(echomat)  # Sum memory traces, add noise
    return(echo)
}
```

## Probe with Category Name

```{r}
CurrentProbe <- c(CategoriesPrototypes[1,1:10],rep(0,13)) #try the first category name, followed by zeros
Echo <- getEcho(CurrentProbe,DistortedExemplars) # create the echo
cor(Echo[11:23],CategoriesPrototypes[1,11:23]) # correlate echo pattern with prototype pattern

# plot the Echo and the Original

Activations <- c(CategoriesPrototypes[1,11:23],Echo[11:23])
Cue <- rep(c("Original","Echo"),each=13)
Neuron <- rep(seq(1:13),2)
dframe <- data.frame(Cue,Neuron,Activations)

ggplot(data=dframe, aes(y=Activations,x=Neuron))+
  geom_bar(stat="identity",position=position_dodge(),fill="gray")+
  theme_classic(base_size=12) +
  ylab("Activation") + xlab("Position")+facet_wrap(~Cue)

```

## Running multiple simulated Subjects

Each simulated subject is shown 3 exemplars from each of three categories. Each of the category names is probed, and the retrieved echo pattern is compared to the prototype pattern. 

```{r}
#loop for each subject
SimulatedDataFrame<-data.frame()
for(subs in 1:20){
  
  #create three categories and prototypes
  #######################
  CategoriesPrototypes <- matrix(sign(runif(3*23,-1,1)),nrow=3,ncol=23)
  
  #Create Distortions
  ###################
  DistortedExemplars <- matrix(nrow = 9, ncol = 23) 
  rowCounter <- 0  # initialize row counter to insert distortions into matrix
  # repeat for each category (rows)
  for (m in 1:3) {
    # create x number of distortions per category
    for (numberOfDistortions in 1:3) {
      rowCounter <- rowCounter + 1  # increment on each loop, simple index
      ones <- rep(1, 23)  # creates a vector of 23 ones
      ones[sample(seq(11, 23), 2)] <- c(-1)  # randomly sample two units from the prototype pattern and change value to -1
      DistortedExemplars[rowCounter, ] <- ones * CategoriesPrototypes[m, ]  # multiply prototype by distortion pattern and save in matrix
    }
  }
  
  #test each category label
  #########################
  SaveCorrelation<-c()
  for (catLabel in 1:3){
    CurrentProbe <- c(CategoriesPrototypes[catLabel,1:10],rep(0,13)) #try the first category name, followed by zeros
    Echo <- getEcho(CurrentProbe,DistortedExemplars) # create the echo
    SaveCorrelation <- c(SaveCorrelation,cor(Echo[11:23],CategoriesPrototypes[catLabel,11:23])) # correlate echo pattern with prototype pattern
  }
  
  #Store the Data
  ################
  StoreData <- data.frame(subject=rep(subs,3),category=seq(1,3),Correlation=SaveCorrelation)
  SimulatedDataFrame <- rbind(SimulatedDataFrame,StoreData)
}

# show the data in a table
#########################
PlotDF <- ddply(SimulatedDataFrame,.(category),summarise,Cor=mean(Correlation),SE=stde(Correlation))
kable(xtable(PlotDF),format="markdown")

```



